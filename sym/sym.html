<html>

<head>
</head>

<body>
  <div class="container">
    </script>
</body>
<script src="js/matter.min.js"> </script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.1/dist/tf.min.js"></script>
<script>
  // create the model
  const model = tf.sequential();
  model.add(tf.layers.dense({units: 3, inputShape: [6]}));
  model.add(tf.layers.dense({units: 3, inputShape: [3], activation: 'sigmoid'}));
  model.compile({loss: 'meanSquaredError', optimizer: 'sgd', metrics: ['accuracy']});

  function initEnvironment() {
    var Engine = Matter.Engine,
      Render = Matter.Render,
      World = Matter.World,
      Bodies = Matter.Bodies,
      Body = Matter.Body,
      Events = Matter.Events,
      Query = Matter.Query,
      Composite = Matter.Composite,
      sensorDistanceFL = sensorDistanceFR = sensorDistanceMax = 200,
      maxSpeed = 200,
      timer = 0,
      maxTimer = 10000,
      multiplier=1,
      featureData = [], 
      labelData = [];

    // create an engine
    var engine = Engine.create();
    engine.world.gravity.y = 0;

    // create a renderer
    var render = Render.create({
      element: document.body,
      engine: engine,
      options: {
        showAngleIndicator: true,
        showDebug: true,
        showVelocity: true,
        showCollisions: true,
      }
    });

    //create the car
    var
      carX = 60,
      carY = 300,
      carLength = 50,
      carWidth = carLength / 5 * 3,
      carBody = Bodies.rectangle(carX, carY, carLength, carWidth),
      sensorRadius = carLength / 15,
      carWheelFL = Bodies.rectangle(carX - carLength / 2 + carLength / 3.5, carY - carWidth / 2, carLength / 3.5, carWidth / 3.5),
      carWheelBL = Bodies.rectangle(carX + carLength / 2 - carLength / 3.5, carY - carWidth / 2, carLength / 3.5, carWidth / 3.5),
      carWheelFR = Bodies.rectangle(carX - carLength / 2 + carLength / 3.5, carY + carWidth / 2, carLength / 3.5, carWidth / 3.5),
      carWheelBR = Bodies.rectangle(carX + carLength / 2 - carLength / 3.5, carY + carWidth / 2, carLength / 3.5, carWidth / 3.5),
      sensorFL = Bodies.circle(carX + carLength / 2 - carLength / 15, carY - carWidth / 2 + carLength * 2 / 15, sensorRadius),
      sensorFR = Bodies.circle(carX + carLength / 2 - carLength / 15, carY + carWidth / 2 - carLength * 2 / 15, sensorRadius),
      car = Body.create({
        parts: [
          carBody,
          carWheelFL,
          carWheelBL,
          carWheelFR,
          carWheelBR,
          sensorFL,
          sensorFR
        ]
      });
    car.frictionAir = 0.1;

    // create two boxes and a ground
    var boxes = [];
    for (i = 0; i < 10; i++) {
      var box = Bodies.rectangle(800 * Math.random(), 600 * Math.random(), 100 * Math.random(), 100 * Math.random(), { isStatic: true });
      boxes.push(box);
    }

    var wallB = Bodies.rectangle(400, 610, 810, 60, { isStatic: true });
    var wallT = Bodies.rectangle(400, 0, 810, 30, { isStatic: true });
    var wallL = Bodies.rectangle(0, 305, 60, 810, { isStatic: true });
    var wallR = Bodies.rectangle(800, 305, 60, 810, { isStatic: true });
    boxes.push(wallB);
    boxes.push(wallT);
    boxes.push(wallL);
    boxes.push(wallR);

    var obstacles = boxes.slice();
    boxes.push(car);


    // add all of the bodies to the world
    World.add(engine.world, boxes);

    // sensors
    Events.on(render, 'afterRender', function () {
      var sensorRange = 200,
        context = render.context,
        bodies = obstacles,
        startPointFL = sensorFL.position,
        startPointFR = sensorFR.position,
        sensorAngleFL = car.angle - 0.785,
        sensorAngleFR = car.angle + 0.785,
        endPointFL = { x: sensorFL.position.x + sensorRange * Math.cos(sensorAngleFL), y: sensorFL.position.y + sensorRange * Math.sin(sensorAngleFL) },
        endPointFR = { x: sensorFR.position.x + sensorRange * Math.cos(sensorAngleFR), y: sensorFR.position.y + sensorRange * Math.sin(sensorAngleFR) };


      sensorDistanceFL = sensorDistanceFR = sensorRange;
      var collisionsFL = Query.ray(bodies, startPointFL, endPointFL);
      var collisionsFR = Query.ray(bodies, startPointFR, endPointFR);

      Render.startViewTransform(render);

      context.beginPath();
      context.moveTo(startPointFL.x, startPointFL.y);

      if (collisionsFL.length > 0) {
        context.strokeStyle = '#fff';
      } else {
        context.strokeStyle = '#555';
      }

      for (var i = 0; i < collisionsFL.length; i++) {
        var collision = collisionsFL[i];
        context.lineTo(collision.supports[0].x, collision.supports[0].y);
        context.rect(collision.bodyA.position.x - 4.5, collision.bodyA.position.y - 4.5, 8, 8);
        sensorDistanceFL = Math.sqrt(Math.pow(sensorFL.position.x - collision.bodyA.position.x, 2) + Math.pow(sensorFL.position.y - collision.bodyA.position.y, 2));
        break;
      }

      context.lineWidth = 0.5;
      context.stroke();


      context.fillStyle = 'rgba(255,165,0,0.7)';
      context.fill();

      context.beginPath();
      context.moveTo(startPointFR.x, startPointFR.y);
      if (collisionsFR.length > 0) {
        context.strokeStyle = '#fff';
      } else {
        context.strokeStyle = '#555';
      }

      for (var i = 0; i < collisionsFR.length; i++) {
        var collision = collisionsFR[i];
        context.lineTo(collision.supports[0].x, collision.supports[0].y);
        context.rect(collision.bodyA.position.x - 4.5, collision.bodyA.position.y - 4.5, 8, 8);
        sensorDistanceFR = Math.sqrt(Math.pow(sensorFR.position.x - collision.bodyA.position.x, 2) + Math.pow(sensorFR.position.y - collision.bodyA.position.y, 2));
        break;
      }

      context.lineWidth = 0.5;
      context.stroke();


      context.fillStyle = 'rgba(255,165,0,0.7)';
      context.fill();

      Render.endViewTransform(render);
    });

    // run the engine
    Engine.run(engine);

    // run the renderer
    Render.run(render);

    function reset() {
      featureData = [];
      labelData = [];
      Matter.Render.stop(render); // this only stop renderer but not destroy canvas
      render.canvas.remove();
      timer = 0;
      initEnvironment();
    }

    function train(featureData, labelData) {
      function onBatchEnd(batch, logs) {
        console.log(logs);
      }

      const xs = tf.tensor2d(featureData, [featureData.length, 6]);
      const ys = tf.tensor2d(labelData, [labelData.length, 3]);

      // Train the model using the data.
      model.fit(xs, ys, 
        {
          epochs: 500,
          callbacks: {onEpochEnd: onBatchEnd}//tf.callbacks.earlyStopping({monitor: 'loss'})
        }).then(() => {
        // Use the model to do inference on a data point the model hasn't seen before:
        // Open the browser devtools to see the output
        model.predict(tf.tensor2d(featureData.slice(-1), [1, 6])).print();
        model.predict(tf.tensor2d([200, 200, 0, 100, 100, 0.5], [1, 6])).print();
        model.predict(tf.tensor2d([200, 200, 0, -100, 100, 0.5], [1, 6])).print();
        model.predict(tf.tensor2d([200, 200, 0, 100, -100, 0.5], [1, 6])).print();
        model.predict(tf.tensor2d([200, 200, 0, -100, -100, 0.5], [1, 6])).print();

        reset();
      });
    }

    function getModelControl(features) {
      speedOptions = [100, -100];
      for(i=0; i<speedOptions.length; i++) {
        for(j=0; j<speedOptions.length; j++) {
          features[3] = speedOptions[i];
          features[4] = speedOptions[j];

          predictions = model.predict(tf.tensor2d(features, [1, features.length]));
          if(predictions.dataSync()[2]>0.5) {
            console.log(features);
            return features;
          }
        }
      }
      if(features[5]<0.5) {
        features[3] = 200 - 400 * Math.random();
        features[4] = 200 - 400 * Math.random();
      } else {
        features[3] = 100;
        features[4] = 100;
      }
      

      return features;
    }

    function addInput() {
      var speed = 100;

      features = [
        sensorDistanceFL, 
        sensorDistanceFR, 
        car.angle, 
        0, 
        0, 
        car.speed
      ];
      featureData.push(features);
      
      labelData.push([
        sensorDistanceFL > 100 ? 1 : 0,
        sensorDistanceFR > 100 ? 1 : 0,
        car.speed > 0.5 ? 1 : 0
      ]);

      features = getModelControl(features);
      leftSpeed = features[3];
      rightSpeed = features[4];

      if (!isNaN(sensorDistanceFR)) {
        leftForce = leftSpeed / 40000 * multiplier;
      } else {
        leftForce = force;
      }
      if (!isNaN(sensorDistanceFL)) {
        rightForce = rightSpeed / 40000 * multiplier;
      } else {
        rightForce = force;
      }
      Body.applyForce(car, { x: car.position.x, y: car.position.y - carWidth / 2 }, { x: leftForce * Math.cos(car.angle), y: leftForce * Math.sin(car.angle) });
      Body.applyForce(car, { x: car.position.x, y: car.position.y + carWidth / 2 }, { x: rightForce * Math.cos(car.angle), y: rightForce * Math.sin(car.angle) });

      timer += 50;
      if (timer > maxTimer) {
        train(featureData, labelData);
        return;
      }
      setTimeout(addInput, 50/multiplier);
    }

    addInput();
  }
  initEnvironment();
</script>

</html>