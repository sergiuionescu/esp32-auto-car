<html>

<head>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
</head>

<body>
<div class="container">
  <div class="row">
    <div class="col">
      <div id="name"></div>
      <div id="canvas-container">
      </div>
    </div>
    <div class="col">
      <div id="high-score">
      </div>
    </div>
    <div class="col">
      <div id="weights">
      </div>
    </div>
  </div>
  <div class="row">
    <div class="col">
      <div id="environment"></div>
    </div>
  </div>
  <div class="row">
    <div>
            <pre>
                <code id="feature-log"></code>
            </pre>
    </div>
  </div>
</div>
</body>
<script src="js/matter.min.js"></script>
<script src="js/raycast.min.js"></script>
<script src="js/chance.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.1/dist/tf.min.js"></script>

<script src="https://code.jquery.com/jquery-3.4.0.min.js"
        integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
        integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
        crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
        crossorigin="anonymous"></script>
<script
    src="https://cdn.polyfill.io/v2/polyfill.js?features=default,String.prototype.repeat,Array.prototype.find,Array.prototype.findIndex,Math.trunc,Math.sign"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.0"></script>
<script>
  class ActorCritic {
    constructor(stateSize, actionSize, reset) {
      this.render = false;
      this.stateSize = stateSize;
      this.actionSize = actionSize;
      this.valueSize = 1;

      this.discountFactor = 0.99;
      this.actorLearningRate = 0.001;
      this.criticLearningRate = 0.005;

      if(!reset) {
        this.load();
      }

      this.actor = this.actor ?? this.buildActor();
      this.critic = this.critic ?? this.buildCritic();
      this.name = this.name ?? new Date().toLocaleString('en-in');


      this.epoch = 0;
      this.latestActorLoss = 0;
      this.latestCriticLoss = 0;
    }

    buildActor() {
      const model = tf.sequential();
      model.add(tf.layers.dense({
        units: 24,
        activation: 'relu',
        kernelInitializer: 'glorotUniform',
        inputShape: [this.stateSize],
      }));

      // model.add(tf.layers.flatten());

      model.add(tf.layers.dense({
        units: this.actionSize,
        activation: 'softmax',
        kernelInitializer: 'glorotUniform',
      }));

      model.compile({
        optimizer: tf.train.adam(this.actorLearningRate),
        loss: tf.losses.softmaxCrossEntropy
      });

      return model;
    }

    buildCritic() {
      const model = tf.sequential();

      model.add(tf.layers.dense({
        units: 24,
        activation: 'relu',
        kernelInitializer: 'glorotUniform',
        inputShape: [this.stateSize],
      }));

      // model.add(tf.layers.flatten());

      model.add(tf.layers.dense({
        units: this.valueSize,
        activation: 'linear',
        kernelInitializer: 'glorotUniform',
      }));

      this.compile(model);

      return model;
    }

    compile(model) {
      model.compile({
        optimizer: tf.train.adam(this.criticLearningRate),
        loss: tf.losses.meanSquaredError,
      });
    }

    getAction(state, actions) {
      let policy = this.actor.predict(tf.tensor2d(normalizer.normalizeFeatures(state), [1, state.length]), {
        batchSize: 1,
      });

      let policyFlat = policy.dataSync();
      pushToWeightsChart(this.epoch, policyFlat);

      return chance.weighted(actions, policyFlat);
    }

    trainModel(state, action, reward, nextState, done) {
      let target = [];
      let advantages = new Array(this.actionSize).fill(0);

      let tfState = tf.tensor2d(normalizer.normalizeFeatures(state), [1, state.length]);
      let tfNextState = tf.tensor2d(normalizer.normalizeFeatures(nextState), [1, nextState.length]);

      let value = this.critic.predict(tfState).dataSync();
      let nextValue = this.critic.predict(tfNextState).dataSync();

      if (done) {
        advantages[action] = reward - value;
        target[0] = reward;
      } else {
        advantages[action] = reward + this.discountFactor * (nextValue) - value;
        target[0] = reward + this.discountFactor * nextValue;
      }

      this.actor.fit(tfState, tf.tensor([advantages]), {
        epochs: 1,
      }).then(info => {
          this.latestActorLoss = info.history.loss[0];
        }
      );

      this.critic.fit(tfState, tf.tensor(target), {
        epochs: 1,
      }).then(info => {
          this.latestCriticLoss = info.history.loss[0];
        }
      );

      pushToEvolutionChart(this.epoch, this.latestActorLoss, this.latestCriticLoss);
      this.epoch++;
    }

    save() {
      this.actor.save('localstorage://actor');
      this.critic.save('localstorage://critic');
      localStorage.setItem('name', this.name);
    }

    load() {
      let name = localStorage.getItem('name');
      if (name != "undefined") {
        tf.loadLayersModel('localstorage://actor').then(model => {
          this.compile(model);
          this.actor = model;
        });
        tf.loadLayersModel('localstorage://critic').then(model => {
          this.compile(model);
          this.critic = model;
        });

        this.name = name;
      }
    }
  }

  var actorCritic = new ActorCritic(3, 4, window.location.hash.substr(1) === 'reset');
  document.getElementById("name").innerHTML = actorCritic.name;

</script>
<script>
  class Nomarlizer {
    normalizeSensorDistance(sensorDistance) {
      sensorDistance = Math.round(sensorDistance/10);
      return sensorDistance / 20;
    }

    normalizeFeatures(features) {
      return [
        this.normalizeSensorDistance(features[0]),
        this.normalizeSensorDistance(features[1]),
        this.normalizeSensorDistance(features[2]),
      ];
    }
  }

  normalizer = new Nomarlizer();
</script>
<script>
  class InputListener {
    leftKeyPressed = false;
    rightKeyPressed = false;
    forwardKeyPressed = false;
    backKeyPressed = false;

    listen() {
      var instance = this;
      $('body').on('keydown', function (e) {
        if (e.which === 37) {
          instance.leftKeyPressed = true;
        } else if (e.which === 39) {
          instance.rightKeyPressed = true;
        } else if (e.which === 38) {
          instance.forwardKeyPressed = true;
        } else if (e.which === 40) {
          instance.backKeyPressed = true;
        }
      });
      $('body').on('keyup', function (e) {
        if (e.which === 37) {
          instance.leftKeyPressed = false;
        } else if (e.which === 39) {
          instance.rightKeyPressed = false;
        } else if (e.which === 38) {
          instance.forwardKeyPressed = false;
        } else if (e.which === 40) {
          instance.backKeyPressed = false;
        }
      });
    }
  }

  listener = new InputListener();
  listener.listen();
</script>
<script>
  class Collider {
    constructor(boxes, car, sensor, name, angleOffset) {
      this.boxes = boxes.slice();
      this.car = car;
      this.sensor = sensor;
      this.name = name;
      this.angleOffset = angleOffset;
    }

    getSensorDistance() {
      let sensorDistance = 200;

      let raycastCollisions = raycast(this.boxes, this.sensor.position,
        {
          x: this.sensor.position.x + sensorDistance * Math.cos(this.car.angle + this.angleOffset),
          y: this.sensor.position.y + sensorDistance * Math.sin(this.car.angle + this.angleOffset)
        }
      );
      if(raycastCollisions.length > 0) {
        let firstHit = raycastCollisions[0];
        sensorDistance = Math.sqrt(Math.pow(this.sensor.position.x - firstHit.point.x, 2)
          + Math.pow(this.sensor.position.y - firstHit.point.y, 2));
      }
      // console.log(this.name + ':' + sensorDistance);
      return sensorDistance;
    }
  }
</script>
<script>
  function createChart() {
    var canvasContainer = document.getElementById('canvas-container');
    var canvas = document.createElement("CANVAS");
    canvasContainer.style.width = 300;
    canvasContainer.appendChild(canvas);
    evolutionChart = new Chart(canvas, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Actor loss',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "#E74C3C",
            data: []
          },
          {
            label: 'Critic loss',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "#16A085",
            data: []
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'Training evolution'
        },
        scales: {
          yAxes: [
            {
              type: "linear", // only linear but allow scale type registration. This allows extensions to exist solely for log scale for instance
              display: true,
              position: "left",
              id: "y-axis-1",
            }
          ],
        }
      }
    });
  }

  function pushToEvolutionChart(epoch, actorLoss, criticLoss) {
    evolutionChart.data.labels.push(epoch);
    evolutionChart.data.datasets[0].data.push(actorLoss);
    evolutionChart.data.datasets[1].data.push(criticLoss);
    if (evolutionChart.data.labels.length > 50) {
      evolutionChart.data.labels.shift();
      evolutionChart.data.datasets[0].data.shift();
      evolutionChart.data.datasets[1].data.shift();
    }
    evolutionChart.update();
  }

  createChart();

</script>

<script>
  function createHighScoreChart() {
    var canvasContainer = document.getElementById('high-score');
    var canvas = document.createElement("CANVAS");
    canvasContainer.style.width = 300;
    canvasContainer.appendChild(canvas);
    highScoreChart = new Chart(canvas, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [
          {
            label: 'score',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "#E74C3C",
            data: []
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'High Score'
        },
        scales: {
          yAxes: [
            {
              type: "linear",
              display: true,
              position: "left",
              id: "y-axis-1",
              ticks: {
                max: 1
              }
            }
          ],
        }
      }
    });
  }

  function pushToHighScoreChart(epoch, score) {
    highScoreChart.data.labels.push(epoch);
    highScoreChart.data.datasets[0].data.push(score);
    if (highScoreChart.data.labels.length > 50) {
      highScoreChart.data.labels.shift();
      highScoreChart.data.datasets[0].data.shift();
    }
    highScoreChart.update();
  }

  createHighScoreChart();

</script>
<script>
  function createWeightsChart() {
    var canvasContainer = document.getElementById('weights');
    var canvas = document.createElement("CANVAS");
    canvasContainer.style.width = 300;
    canvasContainer.appendChild(canvas);
    weightsChart = new Chart(canvas, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Forward',
            fill: false,
            backgroundColor: "#E74C3C",
            data: []
          },
          {
            label: 'Right',
            fill: false,
            backgroundColor: "#16A085",
            data: []
          },
          {
            label: 'Left',
            fill: false,
            backgroundColor: "#1238c1",
            data: []
          },
          {
            label: 'Back',
            fill: false,
            backgroundColor: "#fcca00",
            data: []
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'Weights'
        },
        scales: {
          xAxes: [{
            stacked: true,
          }],
          yAxes: [{
            stacked: true
          }]
        }
      }
    });
  }

  function pushToWeightsChart(epoch, weights) {
    weightsChart.data.labels.push(epoch);
    weightsChart.data.datasets[0].data.push(weights[0]);
    weightsChart.data.datasets[1].data.push(weights[1]);
    weightsChart.data.datasets[2].data.push(weights[2]);
    weightsChart.data.datasets[3].data.push(weights[3]);
    if (weightsChart.data.labels.length > 50) {
      weightsChart.data.labels.shift();
      weightsChart.data.datasets[0].data.shift();
      weightsChart.data.datasets[1].data.shift();
      weightsChart.data.datasets[2].data.shift();
      weightsChart.data.datasets[3].data.shift();
    }
    weightsChart.update();
  }
</script>
<script>
  var iteration = 0,
    evolutionChart,
    highScoreChart,
    weightsChart;
  // create the model
  const model = tf.sequential();
  model.add(tf.layers.dense({units: 10, inputShape: [10], activation: 'relu'}));
  model.add(tf.layers.dense({units: 8, inputShape: [10], activation: 'relu'}));
  model.add(tf.layers.dense({units: 4, inputShape: [8], activation: 'relu'}));
  model.add(tf.layers.dense({units: 2, inputShape: [4]}));
  model.compile({loss: 'meanSquaredError', optimizer: 'adam', metrics: ['accuracy']});
  latest_loss = 1;
  latest_accuracy = 0;

  function initEnvironment() {
    let Engine = Matter.Engine,
      Render = Matter.Render,
      World = Matter.World,
      Events = Matter.Events,
      Bodies = Matter.Bodies,
      Body = Matter.Body,
      sensorDistanceFM = sensorDistanceFL = sensorDistanceFR = sensorDistanceMax = 200,
      timer = 0,
      multiplier = 1;

    createWeightsChart();

    // create an engine
    let engine = Engine.create();
    engine.world.gravity.y = 0;

    // create a renderer
    let render = Render.create({
      element: document.getElementById('environment'),
      engine: engine,
      options: {
        showAngleIndicator: false,
        showDebug: false,
        showVelocity: false,
        showCollisions: false,
        wireframes: false
      }
    });

    //create the car
    let
      carX = 60,
      carY = 300,
      carLength = 50,
      carWidth = carLength / 5 * 3,
      carBody = Bodies.rectangle(carX, carY, carLength, carWidth),
      sensorRadius = carLength / 15,
      carWheelFL = Bodies.rectangle(carX - carLength / 2 + carLength / 3.5, carY - carWidth / 2, carLength / 3.5, carWidth / 3.5),
      carWheelBL = Bodies.rectangle(carX + carLength / 2 - carLength / 3.5, carY - carWidth / 2, carLength / 3.5, carWidth / 3.5),
      carWheelFR = Bodies.rectangle(carX - carLength / 2 + carLength / 3.5, carY + carWidth / 2, carLength / 3.5, carWidth / 3.5),
      carWheelBR = Bodies.rectangle(carX + carLength / 2 - carLength / 3.5, carY + carWidth / 2, carLength / 3.5, carWidth / 3.5),
      sensorFM = Bodies.circle(carX + carLength / 2 - carLength / 15, carY, sensorRadius),
      sensorFL = Bodies.circle(carX + carLength / 2 - carLength / 15, carY - carWidth / 2 + carLength * 2 / 15, sensorRadius),
      sensorFR = Bodies.circle(carX + carLength / 2 - carLength / 15, carY + carWidth / 2 - carLength * 2 / 15, sensorRadius),
      car = Body.create({
        parts: [
          carBody,
          carWheelFL,
          carWheelBL,
          carWheelFR,
          carWheelBR,
          sensorFM,
          sensorFL,
          sensorFR
        ]
      }),
      collisions = 0;

    let obstacles = localStorage.getItem('obstacles') ?? 0;

    let previousState = [],
      previousAction = 0,
      previousReward = 0;

    car.frictionAir = 0.1;

    // create two boxes and a ground
    let boxes = [];

    for (i = 0; i < obstacles; i++) {
      let box = Bodies.rectangle(800 * Math.random(), 600 * Math.random(), 100 + 100 * Math.random(), 100 + 100 * Math.random(), {isStatic: true});
      boxes.push(box);
    }
    let wallB = Bodies.rectangle(400, 600, 810, 20, {isStatic: true});
    let wallT = Bodies.rectangle(400, 0, 810, 20, {isStatic: true});
    let wallL = Bodies.rectangle(0, 305, 20, 810, {isStatic: true});
    let wallR = Bodies.rectangle(800, 305, 20, 810, {isStatic: true});
    boxes.push(wallB);
    boxes.push(wallT);
    boxes.push(wallL);
    boxes.push(wallR);

    let colliderFM = new Collider(boxes, car, sensorFM, 'sensorFM', 0);
    let colliderFL = new Collider(boxes, car, sensorFL, 'sensorFL', -Math.PI / 4);
    let colliderFR = new Collider(boxes, car, sensorFR, 'sensorFR', Math.PI / 4);

    boxes.push(car);

    // add all of the bodies to the world
    World.add(engine.world, boxes);

    Events.on(engine, 'collisionStart', function (event) {
      collisions++;
    });

    // run the engine
    Engine.run(engine);

    // run the renderer
    Render.run(render);

    function reset() {
      iteration++;

      Matter.Render.stop(render); // this only stop renderer but not destroy canvas
      render.canvas.remove();
      timer = 0;
      initEnvironment();
    }

    function addInput() {
      sensorDistanceFM = colliderFM.getSensorDistance()
      sensorDistanceFL = colliderFL.getSensorDistance()
      sensorDistanceFR = colliderFR.getSensorDistance()

      let state = [
        sensorDistanceFM,
        sensorDistanceFL,
        sensorDistanceFR
      ];

      const actions = [
        0, 1, 2, 3,
      ];
      let reward = (
        50 * Math.max(car.speed, 0)
        - Math.min(200 - sensorDistanceFM, 0)
        + Math.abs(50 * Math.cos(car.angle))
      ) / 200;

      let action = actorCritic.getAction(
        state,
        actions
      )
      if (previousState.length > 0) {
        actorCritic.trainModel(previousState, previousAction, previousReward, state, 0);
      }

      previousState = state;
      previousAction = action;
      previousReward = reward;

      let leftSpeed = 0;
      let rightSpeed = 0;
      switch (action) {
        case 0:
          leftSpeed = 200;
          rightSpeed = 200;
          break;
        case 1:
          leftSpeed = 200;
          rightSpeed = -200;
          break;
        case 2:
          leftSpeed = -200;
          rightSpeed = 200;
          break;
        case 4:
          leftSpeed = -200;
          rightSpeed = -200;
      }

      leftForce = leftSpeed / 40000 * multiplier;
      rightForce = rightSpeed / 40000 * multiplier;

      Body.applyForce(car, {
        x: car.position.x + carLength * Math.sin(car.angle) / 2,
        y: car.position.y - carWidth * Math.cos(car.angle) / 2
      }, {x: leftForce * Math.cos(car.angle), y: leftForce * Math.sin(car.angle)});
      Body.applyForce(car, {
        x: car.position.x - carLength * Math.sin(car.angle) / 2,
        y: car.position.y + carWidth * Math.cos(car.angle) / 2
      }, {x: rightForce * Math.cos(car.angle), y: rightForce * Math.sin(car.angle)});

      pushToHighScoreChart(actorCritic.epoch, reward);
      if (actorCritic.epoch > 400) {
        actorCritic.save();
        if(collisions > 0) {
          obstacles--;
          obstacles = Math.max(obstacles, 0);
        } else {
          obstacles += 1;
          obstacles = Math.min(obstacles, 5);
        }
        localStorage.setItem('obstacles', obstacles);
        location.reload();
      }

      setTimeout(addInput, 50 / multiplier);
    }

    addInput();
  }

  initEnvironment();
</script>

</html>