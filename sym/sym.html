<html>

<head>
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css'>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
  <style>
      .btn {
          background-color: #0363c4;
          border: none;
          color: white;
          padding: 12px 16px;
          font-size: 16px;
          cursor: pointer;
      }

      .btn:disabled {
          background-color: #9a9b9b;
      }

      .container {
          width: 100%;
          margin: 0;
          max-width: 100%;
      }
  </style>
</head>

<body>
<div class="container">
  <div class="row">
    <div class="col">
      <button class='btn disabled' id='model_name' name='model_name'><i class='fa fa-info'> Model: <i id="name"></i></i>
      </button>
      <button class='btn' id='download' name='download'><i class='fa fa-download'> Download</i></button>
      <button class='btn' id='pretrained' name='pretrained'><i class='fa fa-hdd-o'> Load pretrained model</i></button>
       Episode: <span id="episode">0</span>
    </div>
  </div>
  <div class="row">
    <div class="col">
      <div id="environment" style="min-width: 1000px;"></div>
    </div>
    <div class="col-sm" style="width: 350px;">
      <div id="reward-chart"></div>
      <div id="training-history-container"></div>
      <div id="weights"></div>
      <div id="sensors" style="width: 350px;"></div>
    </div>
  </div>
  <div class="row">
    <div class="col">
        <h4>Environment</h4>
        <div class="form-group">
          <label for="maxReplayBufferSize" class="form-control-sm">Max replay buffer size</label>
          <input class="form-control form-control-sm" id="maxReplayBufferSize"
                 aria-describedby="Max replay buffer size">
          <label for="obstacles" class="form-control-sm">Obstacles</label>
          <input class="form-control form-control-sm" id="obstacles"
                 aria-describedby="The number of obstacles">
          <label for="cumulativeReward" class="form-control-sm">Cumulative Reward</label>
          <input class="form-control form-control-sm" type="checkbox" id="cumulativeReward"
                 aria-describedby="Cumulate reward on each step">
          <label for="proximityThreshold" class="form-control-sm form-control-sm">Proximity Threshold</label>
          <input class="form-control form-control-sm" id="proximityThreshold"
                 aria-describedby="Sensor distance at which to apply negative reward(1-200)">
        </div>

    </div>
    <div class="col">
      <h4>Hyperparameters</h4>
      <div class="form-group">
        <label for="minEpsilon" class="form-control-sm">Min Epsilon</label>
        <input class="form-control form-control-sm" id="minEpsilon"
               aria-describedby="minEpsilon">
      </div>
      <div class="form-group">
        <label for="epsilon" class="form-control-sm">Epsilon</label>
        <input class="form-control form-control-sm" id="epsilon"
               aria-describedby="epsilon" disabled="disabled">
      </div>
      <div class="form-group">
        <label for="discountFactor" class="form-control-sm">Discount Factor</label>
        <input class="form-control form-control-sm" id="discountFactor"
               aria-describedby="Discount factor">
      </div>
      <div class="form-group">
        <label for="actorLearningRate" class="form-control-sm">Actor Learning Rate</label>
        <input class="form-control form-control-sm" id="actorLearningRate"
               aria-describedby="Actor Learning Rate">
      </div>
      <div class="form-group">
        <label for="criticLearningRate" class="form-control-sm">Critic Learning Rate</label>
        <input class="form-control form-control-sm" id="criticLearningRate"
               aria-describedby="Critic Learning Rate">
      </div>
      <button class='btn float-right' id='save' name='save'><i class='fa fa-refresh'> Save</i></button>
    </div>
    <div class="col">
        <h4>Model</h4>
       <div class="form-group">
          <label for="activeHistoryLength" class="form-control-sm">Active History Length</label>
          <input class="form-control form-control-sm" id="activeHistoryLength"
                 aria-describedby="The number of active features">
        </div>
        <div class="form-group">
          <label for="hiddenUnits" class="form-control-sm">Hidden Units</label>
          <input class="form-control form-control-sm" id="hiddenUnits"
                 aria-describedby="Number of units in the hidden layer">
        </div>
      <button class='btn float-right' id='save-reset' name='save'><i class='fa fa-refresh'> Save & Reset</i></button>
    </div>
  </div>
</div>
</body>
<script src="js/matter.min.js"></script>
<script src="js/raycast.min.js"></script>
<script src="js/chance.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.12.0/dist/tf.min.js"></script>

<script src="https://code.jquery.com/jquery-3.4.0.min.js"
        integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
        integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
        crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
        crossorigin="anonymous"></script>
<script
    src="https://cdn.polyfill.io/v2/polyfill.js?features=default,String.prototype.repeat,Array.prototype.find,Array.prototype.findIndex,Math.trunc,Math.sign"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.0"></script>
<script src="js/perception.chart.js"></script>
<script src="js/collider.js"></script>
<script src="js/normalizer.js"></script>
<script src="js/car.js"></script>
<script src="js/actor.crific.js"></script>
<script>
  let localStorageSize = 0;
  for(var key in window.localStorage){
      if(window.localStorage.hasOwnProperty(key)){
          localStorageSize += window.localStorage[key].length;
      }
  }

  console.log('Using ' + localStorageSize/1024/1024 + ' MB of localStorage space.');
</script>
<script>
  const ACTION_FORWARD = 0;
  const ACTION_RIGHT = 1;
  const ACTION_LEFT = 2;
  const ACTION_BACK = 3;
</script>
<script>
  let reset = window.location.hash.substr(1) === 'reset';
  let historyData = localStorage.getItem('historyData')
  && !reset ? JSON.parse(localStorage.getItem('historyData')) : {
    'averageActorLoss': [],
    'averageCriticLoss': [],
    'averageReward': []
  };
  let reward = 0;

  let wakelock;
  const canWakeLock = () => 'wakeLock' in navigator;
  async function lockWakeState() {
    if(!canWakeLock()) return;
    try {
      wakelock = await navigator.wakeLock.request();
      wakelock.addEventListener('release', () => {
        console.log('Screen Wake State Locked:', !wakelock.released);
      });
      console.log('Screen Wake State Locked:', !wakelock.released);
    } catch(e) {
      console.error('Failed to lock wake state with reason:', e.message);
    }
  }
  lockWakeState();
</script>
<script>
  let config = {
    hiddenUnits: 32,
    obstacles: 0,
    activeHistoryLength: 10,
    cumulativeReward: 0,
    proximityThreshold: 100,
    proximityPenalty: -2,
    collisionPenalty: -5,
    discountFactor: 0.99,
    actorLearningRate: 0.001,
    criticLearningRate: 0.005,
    epsilon: 0.9,
    minEpsilon: 0.1,
    maxReplayBufferSize: 1800,
  }
  if (localStorage.getItem('config')) {
    let savedConfig = JSON.parse(localStorage.getItem('config'));
    for (const key in savedConfig) {
      config[key] = parseFloat(savedConfig[key]);
    }
  }
  let normalizer = new Normalizer(10);
  let actorCritic = new ActorCritic(
    3,
    config.activeHistoryLength,
    3,
    window.location.hash.substr(1) === 'reset',
    window.location.hash.substr(1) === 'act',
    config
  );
  document.getElementById("name").innerHTML = actorCritic.name;

</script>
<script>
  class InputListener {
    leftKeyPressed = false;
    rightKeyPressed = false;
    forwardKeyPressed = false;
    backKeyPressed = false;

    listen() {
      var instance = this;
      $('body').on('keydown', function (e) {
        if (e.which === 65) {
          instance.leftKeyPressed = true;
        } else if (e.which === 68) {
          instance.rightKeyPressed = true;
        } else if (e.which === 87) {
          instance.forwardKeyPressed = true;
        } else if (e.which === 83) {
          instance.backKeyPressed = true;
        }
      });
      $('body').on('keyup', function (e) {
        if (e.which === 65) {
          instance.leftKeyPressed = false;
        } else if (e.which === 68) {
          instance.rightKeyPressed = false;
        } else if (e.which === 87) {
          instance.forwardKeyPressed = false;
        } else if (e.which === 83) {
          instance.backKeyPressed = false;
        }
      });
    }
  }

  listener = new InputListener();
  listener.listen();
</script>

<script>
  function createHistoryChart(historyData) {
    var canvasContainer = document.getElementById('training-history-container');
    var canvas = document.createElement("CANVAS");
    canvasContainer.style.width = 350;
    canvasContainer.appendChild(canvas);
    historyChart = new Chart(canvas, {
      type: 'line',
      data: {
        labels: Object.keys(historyData["averageActorLoss"]),
        datasets: [
          {
            label: 'Actor loss',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "#E74C3C",
            data: historyData['averageActorLoss']
          },
          {
            label: 'Critic loss',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "#16A085",
            data: historyData['averageCriticLoss']
          },
          {
            label: 'Reward',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "#1634a0",
            data: historyData['averageReward']
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'Evolution average history'
        },
        scales: {
          yAxes: [
            {
              type: "linear",
              display: true,
              position: "left",
              id: "y-axis-1",
            }
          ],
        }
      }
    });
  }

  function resetHistoryChart() {
    historyChart.data.labels = [];
    historyChart.data.datasets[0].data = [];
    historyChart.data.datasets[1].data = [];
    historyChart.data.datasets[2].data = [];

    historyChart.update();
  }

  function pushToHistoryChart(loss, type) {
    if(type === 'actor') {
      historyChart.data.datasets[0].data.push(loss);
      if (historyChart.data.datasets[0].data.length > historyChart.data.labels.length) {
        historyChart.data.labels.push(historyChart.data.datasets[0].data.length);
      }
    } else {
      historyChart.data.datasets[1].data.push(loss);
      if (historyChart.data.datasets[1].data.length > historyChart.data.labels.length) {
        historyChart.data.labels.push(historyChart.data.datasets[1].data.length);
      }
    }
    historyChart.update();
  }

  createHistoryChart(historyData);

</script>

<script>
  function createRewardChart() {
    var canvasContainer = document.getElementById('reward-chart');
    var canvas = document.createElement("CANVAS");
    canvasContainer.style.width = 350;
    canvasContainer.appendChild(canvas);
    rewardChart = new Chart(canvas, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'reward',
            yAxisID: 'y-axis-1',
            fill: false,
            backgroundColor: "#157041",
            borderColor: "blue",
            data: []
          },
          {
            label: 'predicted',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "orange",
            data: [],
          },
          {
            label: 'predicted next',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "green",
            data: [],
          },
          {
            label: 'advantage',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "yellow",
            data: [],
            hidden: true,
          },
          {
            label: 'target',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "gray",
            data: [],
            hidden: true,
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'Reward'
        },
        scales: {
          yAxes: [
            {
              type: "linear",
              display: true,
              position: "left",
              id: "y-axis-1"
            }
          ],
        }
      }
    });
  }

  function pushToRewardChart(step, score, predicted, predictedNext, advantage, target) {
    rewardChart.data.labels.push(step);
    rewardChart.data.datasets[0].data.push(score);
    rewardChart.data.datasets[1].data.push(predicted);
    rewardChart.data.datasets[2].data.push(predictedNext);
    rewardChart.data.datasets[3].data.push(advantage);
    rewardChart.data.datasets[4].data.push(target);
    if (rewardChart.data.labels.length > 50) {
      rewardChart.data.labels.shift();
      rewardChart.data.datasets[0].data.shift();
      rewardChart.data.datasets[1].data.shift();
      rewardChart.data.datasets[2].data.shift();
      rewardChart.data.datasets[3].data.shift();
      rewardChart.data.datasets[4].data.shift();
    }
    rewardChart.update();
  }

  createRewardChart();

</script>
<script>
  function createWeightsChart() {
    var canvasContainer = document.getElementById('weights');
    var canvas = document.createElement("CANVAS");
    canvasContainer.style.width = 350;
    canvasContainer.appendChild(canvas);
    weightsChart = new Chart(canvas, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Right',
            fill: false,
            backgroundColor: "#1238c1",
            data: []
          },
          {
            label: 'Forward',
            fill: false,
            backgroundColor: "#16A085",
            data: []
          },
          {
            label: 'Left',
            fill: false,
            backgroundColor: "#E74C3C",
            data: []
          },
          {
            label: 'Back',
            fill: false,
            backgroundColor: "#e7cb3c",
            data: []
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'Weights'
        },
        scales: {
          xAxes: [{
            stacked: true,
          }],
          yAxes: [{
            stacked: true
          }]
        }
      }
    });
  }

  function pushToWeightsChart(step, weights) {
    weightsChart.data.labels.push(step);
    weightsChart.data.datasets[0].data.push(weights[ACTION_RIGHT]);
    weightsChart.data.datasets[1].data.push(weights[ACTION_FORWARD]);
    weightsChart.data.datasets[2].data.push(weights[ACTION_LEFT]);
    weightsChart.data.datasets[3].data.push(weights[ACTION_BACK]);
    if (weightsChart.data.labels.length > 50) {
      weightsChart.data.labels.shift();
      weightsChart.data.datasets[0].data.shift();
      weightsChart.data.datasets[1].data.shift();
      weightsChart.data.datasets[2].data.shift();
      weightsChart.data.datasets[3].data.shift();
    }
    weightsChart.update();
  }
</script>
<script>
  let perceptionChart = new PerceptionChart('sensors', 350, 120);
</script>
<script>
  var historyChart,
    rewardChart,
    weightsChart;
  latest_loss = 1;
  latest_accuracy = 0;

  async function initEnvironment() {
    let Engine = Matter.Engine,
      Render = Matter.Render,
      World = Matter.World,
      Events = Matter.Events,
      Bodies = Matter.Bodies,
      sensorDistanceBM = sensorDistanceFM = sensorDistanceFL = sensorDistanceFR = sensorDistanceMax = 100,
      multiplier = 1;

    createWeightsChart();

    // create an engine
    let engine = Engine.create();
    engine.world.gravity.y = 0;

    // create a renderer
    let environmentWidth = 1000;
    let environmentHeight = 700;
    let render = Render.create({
      element: document.getElementById('environment'),
      engine: engine,
      options: {
        showAngleIndicator: false,
        showDebug: false,
        showVelocity: false,
        showCollisions: false,
        wireframes: false,
        width: environmentWidth,
        height: environmentHeight
      }
    });

    let previousState = [],
      state = [],
      previousAction = ACTION_FORWARD,
      actionBeforePrevious = ACTION_FORWARD,
      previousReward = 0,
      maxReward = 0, 
      previousMinDistance;


    for (let i = 0; i < config.activeHistoryLength; i++) {
      state.push([sensorDistanceMax, sensorDistanceMax, sensorDistanceMax]);
    }

    // create two boxes and a ground
    let boxes = [];

    // for(i=0; i<4;i++) {
    //   let box = Bodies.rectangle(environmentWidth/2 - 400*(i%2) + 200, i*environmentHeight/4, environmentWidth, 10, {isStatic: true});
    //   boxes.push(box);
    // }

    for (i = 0; i < config.obstacles; i++) {
      let box = Bodies.polygon(300 + environmentWidth/2 * Math.random(), environmentHeight * Math.random(), parseInt(3 + 5 * Math.random()), 10 + 50 * Math.random(), {isStatic: true});
      boxes.push(box);
    }
    let wallB = Bodies.rectangle(environmentWidth/2, environmentHeight, environmentWidth+10, 20, {isStatic: true});
    let wallT = Bodies.rectangle(environmentWidth/2, 0, environmentWidth+10, 20, {isStatic: true});
    let wallL = Bodies.rectangle(0, 205, 20, environmentWidth+10, {isStatic: true});
    let wallR = Bodies.rectangle(environmentWidth, 205, 20, environmentWidth+10, {isStatic: true});
    boxes.push(wallB);
    boxes.push(wallT);
    boxes.push(wallL);
    boxes.push(wallR);

    let car = new Car(boxes);
    boxes.push(car.carBody);

    // add all the bodies to the world
    World.add(engine.world, boxes);

    Events.on(engine, 'collisionStart', function (event) {
      car.collisions++;
    });
    Events.on(engine, 'collisionActive', function (event) {
      reward += config.collisionPenalty;
    })

    // run the engine
    Engine.run(engine);

    // run the renderer
    Render.run(render);

    async function addInput() {
      let done = false;
      const actions = [
        0, 1, 2
      ];

      sensorDistanceBM = parseInt(car.colliderBM.getSensorDistance());
      sensorDistanceFM = parseInt(car.colliderFM.getSensorDistance());
      sensorDistanceFL = parseInt(car.colliderFL.getSensorDistance());
      sensorDistanceFR = parseInt(car.colliderFR.getSensorDistance());

      state.push([
        sensorDistanceFL,
        sensorDistanceFM,
        sensorDistanceFR
      ]);
      state.shift();

      if(!config.cumulativeReward) {
        reward = 0;
      }
      let minVisibleDistance = Math.min(sensorDistanceFM, sensorDistanceFL, sensorDistanceFR);
      if(previousMinDistance < minVisibleDistance && minVisibleDistance > config.proximityThreshold) {
        reward = Math.max(0, reward);
      }
      if (previousAction === ACTION_FORWARD && minVisibleDistance > config.proximityThreshold) {
        reward += sensorDistanceMax;
      }
      if (previousAction === ACTION_BACK) {
        reward -= sensorDistanceMax/10;
      }
      reward -= sensorDistanceMax - sensorDistanceBM;
      reward -= sensorDistanceMax - sensorDistanceFM;
      reward -= sensorDistanceMax - sensorDistanceFL;
      reward -= sensorDistanceMax - sensorDistanceFR;

      if(reward > maxReward) {
        maxReward = reward;
      }

      let action = actorCritic.getAction(state, actions);
      if (previousState.length > 0) {
        actorCritic.bufferReplay([...previousState], previousAction, reward, [...state]);
      }

      previousState = [...state];
      actionBeforePrevious = previousAction;
      previousAction = action;
      previousReward = reward;
      previousMinDistance = minVisibleDistance;

      car.act(action);

      if (actorCritic.step > 400 || done || reward < -10000) {
        actorCritic.convertRawTrainingHistory();

        await actorCritic.trainModel();

        actorCritic.save().then( () => {
          historyData['averageActorLoss'].push(
            actorCritic.getAverageActorLoss()
          );
          historyData['averageCriticLoss'].push(
            actorCritic.getAverageCriticLoss()
          );
          historyData['averageReward'].push(
            actorCritic.getAverageReward()
          );
          if (historyData['averageActorLoss'].length > 50) {
            historyData['averageActorLoss'].shift();
            historyData['averageCriticLoss'].shift();
            historyData['averageReward'].shift();
          }
          localStorage.setItem('historyData', JSON.stringify(historyData));

          config.epsilon = Math.max(Math.min(1, (400 - actorCritic.step) * (1 - config.minEpsilon) / 400), config.minEpsilon);
          saveConfigToStorage();

          window.location.href = window.location.href.split('#')[0];
        });

      } else {
        setTimeout(addInput, 50 / multiplier);
      }
    }

    addInput();
  }

  initEnvironment();
</script>
<script>
  function updateConfigUi() {
    for (const key in config) {
      if (document.getElementById(key)) {
        if(document.getElementById(key).type === 'checkbox') {
          document.getElementById(key).checked = config[key] === 1;
        } else {
          document.getElementById(key).value = config[key];
        }
      }
    }
  }

  document.getElementById('save-reset').onclick = function () {
    document.getElementById('epsilon').value = 1;
    saveConfig();
    if (window.location.hash.substr(1) !== 'reset') {
      window.location = window.location + '#reset';
    }
    location.reload();
  };

  function saveConfigToStorage() {
    localStorage.setItem('config', JSON.stringify(config));
  }

  function saveConfig() {
    for (const key in config) {
      if (document.getElementById(key)) {
        if (document.getElementById(key).type === 'checkbox') {
          config[key] = document.getElementById(key).checked === true ? 1 : 0;
        } else {
          config[key] = document.getElementById(key).value;
        }
      }
    }
    saveConfigToStorage();
  }

  document.getElementById('save').onclick = function () {
    saveConfig();
    location.reload();
  }


  document.getElementById('pretrained').onclick = function () {
    let path = 'model/'
    $.get(path + 'config.json', function (data) {
      config = data;
      updateConfigUi();
      actorCritic.load(path + 'actor.json', path + 'critic.json', false);
    });
  }

  document.getElementById('download').onclick = function () {
    actorCritic.actor.save('downloads://actor');
    actorCritic.critic.save('downloads://critic');
  };
  updateConfigUi();
</script>
</html>