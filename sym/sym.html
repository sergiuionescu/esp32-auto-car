<html>

<head>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
    integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
</head>

<body>
  <div class="container">
    <div class="row">
      <div class="col">
        <div id="environment"></div>
      </div>
      <div class="col">
        <div>
          <span class="label label-default">Queued</span>
          <span class="label label-primary" id="train_queued">0</span>
        </div>
        <div>
          <span class="label label-default">Trained</span>
          <span class="label label-primary" id="train_batch">0</span>
        </div>
        <div>
          <span class="label label-default">qSpeed</span>
          <span class="label label-primary" id="q_speed">0</span>
        </div>
        <div id="canvas-container" width="100px">
        </div>

      </div>
    </div>
    <div class="row">
        <div>
            <pre>
                <code id="feature-log"></code>
            </pre>
          </div>
    </div>
</body>
<script src="js/matter.min.js"> </script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.1/dist/tf.min.js"></script>

<script src="https://code.jquery.com/jquery-3.4.0.min.js"
  integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
  integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
  integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
<script
  src="https://cdn.polyfill.io/v2/polyfill.js?features=default,String.prototype.repeat,Array.prototype.find,Array.prototype.findIndex,Math.trunc,Math.sign"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.0"></script>
<script>
  class Nomarlizer {
    normalizeSensorDistance(sensorDistance) {
      return (Math.min(sensorDistance,200)) / 200;
    }

    denormalizeSensorDistance(prediction) {
      return (prediction) * 200;
    }

    normalizeSpeed(speed) {
      return (10 + speed) / 20;
    }

    denormalizeSpeed(prediction) {
      return prediction * 20 - 10;
    }

    normalizeControlSpeed(speed) {
      return (200 + speed)/400;
    }

    denormalizeControlSpeed(prediction) {
      return prediction * 400 - 200;
    }

    normalizeAngle(angle) {
      return (Math.PI + angle) / (2 * Math.PI);
    }

    normalizeInput(input) {
      return input > 0 ? 1 : 0;
    }

    normalizeFeatures(features) {
      return [
        this.normalizeSensorDistance(features[0]),
        this.normalizeSensorDistance(features[1]),
        this.normalizeSensorDistance(features[2]),
        this.normalizeAngle(features[3]),
        this.normalizeSpeed(features[4]),
        this.normalizeSensorDistance(features[5]),
        this.normalizeSensorDistance(features[6]),
        this.normalizeSensorDistance(features[7]),
        this.normalizeAngle(features[8]),
        this.normalizeSpeed(features[9])
      ];
    }

    normalizeLabels(labels) {
      return [
        this.normalizeControlSpeed(labels[0]),
        this.normalizeControlSpeed(labels[1])
      ];
    }
   }
   normalizer = new Nomarlizer();
</script>
<script>
  var trainingQueue = [],
    inTraining = false,
    experience = 0,
    evolutionChart;
  // create the model
  const model = tf.sequential();
  model.add(tf.layers.dense({ units: 10, inputShape: [10], activation: 'relu' }));
  model.add(tf.layers.dense({ units: 8, inputShape: [10], activation: 'relu'  }));
  model.add(tf.layers.dense({ units: 4, inputShape: [8], activation: 'relu'  }));
  model.add(tf.layers.dense({ units: 2, inputShape: [4], activation: 'sigmoid' }));
  model.compile({ loss: 'meanSquaredError', optimizer: 'sgd', metrics: ['accuracy'] });
  latest_loss = 1;
  latest_accuracy = 0;

  function initEnvironment() {
    var Engine = Matter.Engine,
      Render = Matter.Render,
      World = Matter.World,
      Bodies = Matter.Bodies,
      Body = Matter.Body,
      Events = Matter.Events,
      Query = Matter.Query,
      Composite = Matter.Composite,
      sensorDistanceFM = sensorDistanceFL = sensorDistanceFR = sensorDistanceMax = 200,
      maxSpeed = 200,
      timer = 0,
      maxTimer = 10000,
      multiplier = 1,
      previousFeatures = [0, 0, 0, 0, 0];
      featureData = [],
      labelData = []
      qSpeed = 0,
      qSpeedDecay = 1,
      previousSensorDistanceFM = 0;

    // create an engine
    var engine = Engine.create();
    engine.world.gravity.y = 0;

    // create a renderer
    var render = Render.create({
      element: document.getElementById('environment'),
      engine: engine,
      options: {
        showAngleIndicator: true,
        showDebug: true,
        showVelocity: true,
        showCollisions: true,
      }
    });

    //create the car
    var
      carX = 60,
      carY = 300,
      carLength = 50,
      carWidth = carLength / 5 * 3,
      carBody = Bodies.rectangle(carX, carY, carLength, carWidth),
      sensorRadius = carLength / 15,
      carWheelFL = Bodies.rectangle(carX - carLength / 2 + carLength / 3.5, carY - carWidth / 2, carLength / 3.5, carWidth / 3.5),
      carWheelBL = Bodies.rectangle(carX + carLength / 2 - carLength / 3.5, carY - carWidth / 2, carLength / 3.5, carWidth / 3.5),
      carWheelFR = Bodies.rectangle(carX - carLength / 2 + carLength / 3.5, carY + carWidth / 2, carLength / 3.5, carWidth / 3.5),
      carWheelBR = Bodies.rectangle(carX + carLength / 2 - carLength / 3.5, carY + carWidth / 2, carLength / 3.5, carWidth / 3.5),
      sensorFM = Bodies.circle(carX + carLength / 2 - carLength / 15, carY, sensorRadius),
      sensorFL = Bodies.circle(carX + carLength / 2 - carLength / 15, carY - carWidth / 2 + carLength * 2 / 15, sensorRadius),
      sensorFR = Bodies.circle(carX + carLength / 2 - carLength / 15, carY + carWidth / 2 - carLength * 2 / 15, sensorRadius),
      car = Body.create({
        parts: [
          carBody,
          carWheelFL,
          carWheelBL,
          carWheelFR,
          carWheelBR,
          sensorFM,
          sensorFL,
          sensorFR
        ]
      });
    car.frictionAir = 0.1;

    // create two boxes and a ground
    var boxes = [];
    for (i = 0; i < (1 - latest_loss) * 10; i++) {
      var box = Bodies.rectangle(800 * Math.random(), 600 * Math.random(), 100 * Math.random(), 100 * Math.random(), { isStatic: true });
      boxes.push(box);
    }

    var wallB = Bodies.rectangle(400, 610, 810, 60, { isStatic: true });
    var wallT = Bodies.rectangle(400, 0, 810, 30, { isStatic: true });
    var wallL = Bodies.rectangle(0, 305, 60, 810, { isStatic: true });
    var wallR = Bodies.rectangle(800, 305, 60, 810, { isStatic: true });
    boxes.push(wallB);
    boxes.push(wallT);
    boxes.push(wallL);
    boxes.push(wallR);

    var obstacles = boxes.slice();
    boxes.push(car);


    // add all of the bodies to the world
    World.add(engine.world, boxes);

    // sensors
    Events.on(render, 'afterRender', function () {
      var sensorRange = 200,
        context = render.context,
        bodies = obstacles,
        startPointFM = sensorFM.position,
        startPointFL = sensorFL.position,
        startPointFR = sensorFR.position,
        sensorAngleFM = car.angle,
        sensorAngleFL = car.angle - 0.785,
        sensorAngleFR = car.angle + 0.785,
        endPointFM = { x: sensorFL.position.x + sensorRange * Math.cos(sensorAngleFM), y: sensorFL.position.y + sensorRange * Math.sin(sensorAngleFM) },
        endPointFL = { x: sensorFL.position.x + sensorRange * Math.cos(sensorAngleFL), y: sensorFL.position.y + sensorRange * Math.sin(sensorAngleFL) },
        endPointFR = { x: sensorFR.position.x + sensorRange * Math.cos(sensorAngleFR), y: sensorFR.position.y + sensorRange * Math.sin(sensorAngleFR) };


      sensorDistanceFM = sensorDistanceFL = sensorDistanceFR = sensorRange;
      var collisionsFM = Query.ray(bodies, startPointFM, endPointFM);
      var collisionsFL = Query.ray(bodies, startPointFL, endPointFL);
      var collisionsFR = Query.ray(bodies, startPointFR, endPointFR);

      Render.startViewTransform(render);

      context.beginPath();
      context.moveTo(startPointFL.x, startPointFL.y);

      if (collisionsFL.length > 0) {
        context.strokeStyle = '#fff';
      } else {
        context.strokeStyle = '#555';
      }

      for (var i = 0; i < collisionsFL.length; i++) {
        var collision = collisionsFL[i];
        context.lineTo(collision.supports[0].x, collision.supports[0].y);
        context.rect(collision.bodyA.position.x - 4.5, collision.bodyA.position.y - 4.5, 8, 8);
        sensorDistanceFL = Math.sqrt(Math.pow(sensorFL.position.x - collision.bodyA.position.x, 2) + Math.pow(sensorFL.position.y - collision.bodyA.position.y, 2));
        break;
      }

      context.lineWidth = 0.5;
      context.stroke();
      context.fillStyle = 'rgba(255,165,0,0.7)';
      context.fill();

      context.beginPath();
      context.moveTo(startPointFM.x, startPointFM.y);

      if (collisionsFM.length > 0) {
        context.strokeStyle = '#fff';
      } else {
        context.strokeStyle = '#555';
      }

      for (var i = 0; i < collisionsFM.length; i++) {
        var collision = collisionsFM[i];
        context.lineTo(collision.supports[0].x, collision.supports[0].y);
        context.rect(collision.bodyA.position.x - 4.5, collision.bodyA.position.y - 4.5, 8, 8);
        sensorDistanceFM = Math.sqrt(Math.pow(sensorFM.position.x - collision.bodyA.position.x, 2) + Math.pow(sensorFM.position.y - collision.bodyA.position.y, 2));
        break;
      }

      context.lineWidth = 0.5;
      context.stroke();
      context.fillStyle = 'rgba(255,165,0,0.7)';
      context.fill();

      context.beginPath();
      context.moveTo(startPointFR.x, startPointFR.y);
      if (collisionsFR.length > 0) {
        context.strokeStyle = '#fff';
      } else {
        context.strokeStyle = '#555';
      }

      for (var i = 0; i < collisionsFR.length; i++) {
        var collision = collisionsFR[i];
        context.lineTo(collision.supports[0].x, collision.supports[0].y);
        context.rect(collision.bodyA.position.x - 4.5, collision.bodyA.position.y - 4.5, 8, 8);
        sensorDistanceFR = Math.sqrt(Math.pow(sensorFR.position.x - collision.bodyA.position.x, 2) + Math.pow(sensorFR.position.y - collision.bodyA.position.y, 2));
        break;
      }

      context.lineWidth = 0.5;
      context.stroke();
      context.fillStyle = 'rgba(255,165,0,0.7)';
      context.fill();

      Render.endViewTransform(render);
    });

    // run the engine
    Engine.run(engine);

    // run the renderer
    Render.run(render);

    function reset() {
      enqueueForTraining(featureData, labelData);
      qSpeed = 0;
      featureData = [];
      labelData = [];
      Matter.Render.stop(render); // this only stop renderer but not destroy canvas
      render.canvas.remove();
      timer = 0;
      initEnvironment();
    }

    function enqueueForTraining(featureData, labelData) {
      if(trainingQueue.length < 2) {
        trainingQueue.push([featureData, labelData]);
        document.getElementById('train_queued').innerHTML = trainingQueue.length;
      }
      if (!inTraining) {
        train();
      }
    }

    function train() {
      if (trainingQueue.length == 0 || inTraining) {
        console.log('Nothing to train on or already in training.')
        return;
      }
      trainingSet = trainingQueue.shift().slice();
      var featureData = trainingSet[0];
      var labelData = trainingSet[1];
      document.getElementById('train_queued').innerHTML = trainingQueue.length;
      experience += 1;

      console.log('Start training ' + experience);
      inTraining = true;
      function onBatchEnd(batch, logs) {
        latest_loss = logs.loss;
        latest_accuracy = logs.acc;
      }

      try {
        featureLength = featureData[featureData.length - 1].length;
        const xs = tf.tensor2d(featureData, [featureData.length, featureLength]);
        const ys = tf.tensor2d(labelData, [labelData.length, 2]);


        // Train the model using the data.
        model.fit(xs, ys,
          {
            epochs: 500,
            callbacks: { onEpochEnd: onBatchEnd }//tf.callbacks.earlyStopping({monitor: 'loss'})
          }).then(() => {

            model.predict(tf.tensor2d(featureData.slice(-1), [1, featureLength])).print();

            inTraining = false;
            document.getElementById('train_batch').innerHTML = experience;
            pushToEvolutionChart(experience, latest_loss, latest_accuracy);
            console.log('Finished training ' + experience);
            setTimeout(train, 10000);
          });
      } catch (err) {
        console.log(err.message);
        inTraining = false;
      }
    }

    function getModelControl(features) {
      if (Math.random() > (10 - experience % 10) / 10) {
        predictions = model.predict(tf.tensor2d(normalizer.normalizeFeatures(features), [1, features.length]));
        leftSpeed = normalizer.denormalizeControlSpeed(predictions.dataSync()[0]);
        rightSpeed = normalizer.denormalizeControlSpeed(predictions.dataSync()[1]);
        
        control = [leftSpeed, rightSpeed];
        document.getElementById('feature-log').innerHTML = JSON.stringify(control);
        return control;
      }

      return [
        200 - 400 * Math.round(Math.random()),
        200 - 400 * Math.round(Math.random())
      ];
    }

    function addInput() {
      var speed = 100;

      var currentFeatures = [
        sensorDistanceFM,
        sensorDistanceFL,
        sensorDistanceFR,
        car.angle,
        car.speed
      ];
      qSpeed += car.speed - qSpeedDecay;
      features = previousFeatures.concat(currentFeatures);
      previousFeatures = currentFeatures;

      control = getModelControl(features);
      leftSpeed = control[0];
      rightSpeed = control[1];

      if(sensorDistanceFM > previousSensorDistanceFM) {
        featureData.push(normalizer.normalizeFeatures(features));
        labelData.push(normalizer.normalizeLabels([
          leftSpeed ,
          rightSpeed
        ]));
      }
      previousSensorDistanceFM = sensorDistanceFM;

      leftSpeed += 50;
      rightSpeed += 50;

      if (!isNaN(sensorDistanceFR)) {
        leftForce = leftSpeed / 40000 * multiplier;
      } else {
        leftForce = force;
      }
      if (!isNaN(sensorDistanceFL)) {
        rightForce = rightSpeed / 40000 * multiplier;
      } else {
        rightForce = force;
      }
      Body.applyForce(car, { x: car.position.x + carLength * Math.sin(car.angle) / 2, y: car.position.y - carWidth * Math.cos(car.angle) / 2 }, { x: leftForce * Math.cos(car.angle), y: leftForce * Math.sin(car.angle) });
      Body.applyForce(car, { x: car.position.x - carLength * Math.sin(car.angle) / 2, y: car.position.y + carWidth * Math.cos(car.angle) / 2 }, { x: rightForce * Math.cos(car.angle), y: rightForce * Math.sin(car.angle) });

      timer += 50;
      document.getElementById('q_speed').innerHTML = qSpeed;
      if (timer > maxTimer || qSpeed < -10) {
        reset();
        return;
      }
      setTimeout(addInput, 50 / multiplier);
    }

    addInput();
  }
  initEnvironment();
</script>
<script>
  function createChart() {
    var canvasContainer = document.getElementById('canvas-container');
    var canvas = document.createElement("CANVAS");
    canvas.width = 100;
    canvas.height = 100;
    canvasContainer.appendChild(canvas);
    evolutionChart = new Chart(canvas, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'loss',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "#E74C3C",
            data: []
          },
          {
            label: 'acc',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "#16A085",
            data: []
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'Training evolution'
        },
        scales: {
          yAxes: [
            {
              type: "linear", // only linear but allow scale type registration. This allows extensions to exist solely for log scale for instance
              display: true,
              position: "left",
              id: "y-axis-1",
            }
          ],
        }
      }
    });
  }
  function pushToEvolutionChart(epoch, loss, accuracy) {
    evolutionChart.data.labels.push(epoch);
    evolutionChart.data.datasets[0].data.push(loss);
    evolutionChart.data.datasets[1].data.push(accuracy);
    evolutionChart.update();
  }
  createChart();

</script>

</html>