<html>

<head>
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css'>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
  <style>
      .btn {
          background-color: #0363c4;
          border: none;
          color: white;
          padding: 12px 16px;
          font-size: 16px;
          cursor: pointer;
      }

      .btn:disabled {
          background-color: #9a9b9b;
      }

      .container {
          width: 100%;
      }
  </style>
</head>

<body>
<div class="container">
  <div class="row">
    <div class="col">
      <button class='btn disabled' id='model_name' name='model_name'><i class='fa fa-info'> Model: <i id="name"></i></i>
      </button>
      <button class='btn' id='download' name='download'><i class='fa fa-download'> Download</i></button>
      <button class='btn' id='pretrained' name='pretrained'><i class='fa fa-hdd-o'> Load pretrained model</i></button>
       Episode: <span id="episode">0</span>
    </div>
  </div>
  <div class="row">
    <div class="col">
      <div id="reward-chart">
      </div>
      <div id="training-history-container">
      </div>

    </div>
    <div class="col">
      <div id="weights">
      </div>
       <div id="sensors">
      </div>
    </div>
  </div>
  <div class="row">
    <div class="col">
      <div id="environment"></div>
    </div>
    <div class="col">
    </div>
  </div>
  <div class="row">
    <div class="col">
        <h4>Environment</h4>
        <div class="form-group">
          <label for="obstacles" class="form-control-sm">Obstacles</label>
          <input class="form-control form-control-sm" id="obstacles"
                 aria-describedby="The number of obstacles">
        </div>
        <div class="form-group">
          <label for="cumulativeReward" class="form-control-sm">Cumulative Reward</label>
          <input class="form-control form-control-sm" type="checkbox" id="cumulativeReward"
                 aria-describedby="Cumulate reward on each step">
          <label for="proximityThreshold" class="form-control-sm form-control-sm">Proximity Threshold</label>
          <input class="form-control form-control-sm" id="proximityThreshold"
                 aria-describedby="Sensor distance at which to apply negative reward(1-200)">
<!--          <label for="proximityPenalty" class="form-control-sm">Proximity Penalty</label>-->
<!--          <input class="form-control form-control-sm" id="proximityPenalty"-->
<!--                 aria-describedby="Penalty for the front sensor reporting a distance lesser than the threshold">-->
<!--          <label for="collisionPenalty" class="form-control-sm">Collision Penalty</label>-->
<!--          <input class="form-control form-control-sm" id="collisionPenalty"-->
<!--                 aria-describedby="Penalty for colliding with a wall or box">-->
        </div>

    </div>
    <div class="col">
      <h4>Hyperparameters</h4>
      <div class="form-group">
        <label for="epsilon" class="form-control-sm">Epsilon</label>
        <input class="form-control form-control-sm" id="epsilon"
               aria-describedby="epsilon">
      </div>
      <div class="form-group">
        <label for="discountFactor" class="form-control-sm">Discount Factor</label>
        <input class="form-control form-control-sm" id="discountFactor"
               aria-describedby="Discount factor">
      </div>
      <div class="form-group">
        <label for="actorLearningRate" class="form-control-sm">Actor Learning Rate</label>
        <input class="form-control form-control-sm" id="actorLearningRate"
               aria-describedby="Actor Learning Rate">
      </div>
      <div class="form-group">
        <label for="criticLearningRate" class="form-control-sm">Critic Learning Rate</label>
        <input class="form-control form-control-sm" id="criticLearningRate"
               aria-describedby="Critic Learning Rate">
      </div>
      <button class='btn float-right' id='save' name='save'><i class='fa fa-refresh'> Save</i></button>
    </div>
    <div class="col">
        <h4>Model</h4>
       <div class="form-group">
          <label for="activeHistoryLength" class="form-control-sm">Active History Length</label>
          <input class="form-control form-control-sm" id="activeHistoryLength"
                 aria-describedby="The number of active features">
        </div>
        <div class="form-group">
          <label for="hiddenUnits" class="form-control-sm">Hidden Units</label>
          <input class="form-control form-control-sm" id="hiddenUnits"
                 aria-describedby="Number of units in the hidden layer">
        </div>
      <button class='btn float-right' id='save-reset' name='save'><i class='fa fa-refresh'> Save & Reset</i></button>
    </div>
  </div>
</div>
</body>
<script src="js/matter.min.js"></script>
<script src="js/raycast.min.js"></script>
<script src="js/chance.min.js"></script>
<script src="js/dexie.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.12.0/dist/tf.min.js"></script>

<script src="https://code.jquery.com/jquery-3.4.0.min.js"
        integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
        integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
        crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
        crossorigin="anonymous"></script>
<script
    src="https://cdn.polyfill.io/v2/polyfill.js?features=default,String.prototype.repeat,Array.prototype.find,Array.prototype.findIndex,Math.trunc,Math.sign"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.0"></script>
<script>
  class KeyValueStore {
    constructor() {
      this.db = new Dexie("sym");
      this.db.version(1).stores({
        keyValue: 'keyPath, value'
      })
    }

    async set(keyPath, value) {
      const key = await this.db.keyValue.put({keyPath, value}, keyPath);
    }

    async get(key) {
      let data = await this.db.keyValue.get(key);
      return data !== undefined ? data['value'] : '[]';
    }
  }
let keyValueStore = new KeyValueStore();
</script>
<script>
  let reset = window.location.hash.substr(1) === 'reset';
  let historyData = localStorage.getItem('historyData')
  && !reset ? JSON.parse(localStorage.getItem('historyData')) : {
    'averageActorLoss': [],
    'averageCriticLoss': [],
    'averageReward': []
  };
  let reward = 0;

  let wakelock;
  const canWakeLock = () => 'wakeLock' in navigator;
  async function lockWakeState() {
    if(!canWakeLock()) return;
    try {
      wakelock = await navigator.wakeLock.request();
      wakelock.addEventListener('release', () => {
        console.log('Screen Wake State Locked:', !wakelock.released);
      });
      console.log('Screen Wake State Locked:', !wakelock.released);
    } catch(e) {
      console.error('Failed to lock wake state with reason:', e.message);
    }
  }
  lockWakeState();
</script>
<script>
  class ActorCritic {
    constructor(featureCount, historyLength, actionSize, reset, act, config) {
      this.render = false;
      this.featureCount = featureCount;
      this.historyLength = historyLength;
      this.actionSize = actionSize;
      this.replayBuffer = [];
      this.replayBufferSize = 1200;
      this.valueSize = 1;
      this.act = act;

      this.episode = 0;
      this.averageReward = 0;

      this.config = config;

      if (!reset) {
        this.load();
      }

      this.commonLayer = tf.layers.dense({
        units: parseInt(this.config.hiddenUnits),
        activation: 'relu',
        kernelInitializer: 'glorotUniform',
      });
      this.actor = this.actor ?? this.buildActor();
      this.critic = this.critic ?? this.buildCritic();
      this.name = this.name ?? new Date().toLocaleString('en-in');
      this.trainingBuffer = {
        'tfState': [],
        'advantages': [],
        'targets': []
      };


      this.step = 0;
      this.latestActorLoss = 0;
      this.latestCriticLoss = 0;

      this.actorLosses = [];
      this.criticLosses = [];
      this.rewards = [];
    }

    customActorLoss(logProb, advantages) {
      return tf.tidy(() => {
        // Multiply the log probability by the advantages
        const loss = tf.mul(logProb, advantages);

        // Take the negative of the mean (since we want to maximize expected returns)
        return tf.neg(tf.mean(loss));
      });
    }

    buildActor() {
      const model = tf.sequential();
      model.add(tf.layers.inputLayer({inputShape: [this.historyLength * this.featureCount],}));

      model.add(this.commonLayer);

      model.add(tf.layers.dense({
        units: this.actionSize,
        activation: 'softmax',
        kernelInitializer: 'glorotUniform',
      }));

      this.compile(model, config.actorLearningRate, this.customActorLoss);

      return model;
    }

    buildCritic() {
      const model = tf.sequential();

      model.add(tf.layers.inputLayer({inputShape: [this.historyLength * this.featureCount],}));

      model.add(this.commonLayer);

      model.add(tf.layers.dense({
        units: this.valueSize,
        activation: 'linear',
        kernelInitializer: 'glorotUniform',
      }));

      this.compile(model, config.criticLearningRate, tf.losses.huberLoss);

      return model;
    }

    compile(model, learningRate, loss) {
      model.compile({
        optimizer: tf.train.adam(learningRate),
        loss: loss,
      });
    }

    getAction(state, actions) {
      let policy = this.actor.predict(tf.tensor2d(normalizer.normalizeFeatures(state), [1, state.length * state[0].length]), {
        batchSize: 1,
      });

      let policyFlat = policy.dataSync();
      let weights = [parseFloat(policyFlat[0]), parseFloat(policyFlat[1]), parseFloat(policyFlat[2]), parseFloat(policyFlat[3])];
      pushToSensorsChart(this.step, state);
      pushToWeightsChart(this.step, weights);

      let action = chance.weighted(actions, weights);
      if(Math.random() < this.config.epsilon) {
        action = chance.weighted(actions, [1,1,1,1]);
      }

      return action;
    }

    bufferReplay(previousState, previousAction, reward, state) {
      this.replayBuffer.push({previousState, previousAction, reward, state});
      this.computeTrainingData(previousState, state, reward);

      this.step ++;
    }

    convertRawTrainingHistory() {
      this.replayBuffer.forEach(async (data) => {
        await actorCritic.bufferTrainingData(data.previousState, data.previousAction, data.reward, data.state);
      })
    }

    async bufferTrainingData(state, action, reward, nextState) {
      let {advantages, normalizedState, target, advantage} = this.computeTrainingData(state, nextState, reward, false);

      advantages[action] = advantage;

      this.trainingBuffer['tfState'].push(normalizedState);
      this.trainingBuffer['advantages'].push(advantages);
      this.trainingBuffer['targets'].push(target);

      this.rewards.push(reward);
    }

    computeTrainingData(previousState, state, reward, chart=true) {
      let advantages = new Array(this.actionSize).fill(0);

      let normalizedPreviousState = normalizer.normalizeFeatures(previousState);
      let tfPreviousState = tf.tensor2d(normalizedPreviousState, [1, normalizedPreviousState.length]);
      let predictedPreviousStateValue = this.critic.predict(tfPreviousState).dataSync();

      let normalizedState = normalizer.normalizeFeatures(state);
      let tfState = tf.tensor2d(normalizedState, [1, normalizedState.length]);
      let predictedStateValue = this.critic.predict(tfState).dataSync();

      let target = reward + config.discountFactor * predictedStateValue;
      let advantage = target - predictedPreviousStateValue;

      if(chart) {
        pushToRewardChart(actorCritic.step, reward, parseFloat(predictedPreviousStateValue), parseFloat(predictedStateValue), advantage, target);
      }

      return {advantages, normalizedState: normalizedPreviousState, target, advantage};
    }

    async trainModel() {
      let epochs = 50;
      let batchSize = 64;

      let tfState = tf.tensor2d(
        this.trainingBuffer['tfState'],
        [this.trainingBuffer['tfState'].length, this.trainingBuffer['tfState'][0].length]
      );
      let advantages = tf.tensor(this.trainingBuffer['advantages']);
      let targets = tf.tensor(this.trainingBuffer['targets']);

      resetHistoryChart();
      function onActorEpochEnd(batch, logs) {
        pushToHistoryChart(logs.loss, 'actor')
      }

      function onCriticEpochEnd(batch, logs) {
        pushToHistoryChart(logs.loss, 'critic')
      }

      await this.actor.fit(tfState, advantages, {
        epochs: epochs,
        batchSize: batchSize,
        callbacks: {
          onEpochEnd: onActorEpochEnd,
          earlyStopping: tf.callbacks.earlyStopping
        }
      }).then(info => {
          this.latestActorLoss = info.history.loss.slice(-1);
          this.actorLosses.push(this.latestActorLoss[0]);
        }
      );

      await this.critic.fit(tfState, targets, {
        epochs: epochs,
        batchSize: batchSize,
        callbacks: {
          onEpochEnd: onCriticEpochEnd,
          earlyStopping: tf.callbacks.earlyStopping
        }
      }).then(info => {
          this.latestCriticLoss = info.history.loss.slice(-1);
          this.criticLosses.push(this.latestCriticLoss[0]);
        }
      );
    }

    async save() {
      await this.actor.save('localstorage://actor');
      await this.critic.save('localstorage://critic');

      this.averageReward = (this.averageReward * this.episode + reward) / (this.episode + 1);
      this.episode++;

      localStorage.setItem('replayBuffer', JSON.stringify(this.replayBuffer.slice(-this.replayBufferSize)));
      localStorage.setItem('episode', this.episode);
      localStorage.setItem('averageReward', this.averageReward);
      localStorage.setItem('name', this.name);
    }

    async load(actorPath = 'localstorage://actor', criticPath = 'localstorage://critic') {
      let name = localStorage.getItem('name');
      if (name != "undefined") {
        tf.loadLayersModel(actorPath).then(model => {
          this.compile(model, config.actorLearningRate, this.customActorLoss);
          this.actor = model;
        });
        tf.loadLayersModel(criticPath).then(model => {
          model.layers[1] = this.actor.layers[1];
          this.compile(model, config.criticLearningRate, tf.losses.huberLoss);
          this.critic = model;
        });
        this.name = name;
        this.episode = localStorage.getItem('episode');
        this.replayBuffer = JSON.parse(localStorage.getItem('replayBuffer'));
        this.averageReward = localStorage.getItem('averageReward');
        document.getElementById('episode').innerText = this.episode;
      }
    }

    getAverageActorLoss() {
      return this.getAverage(this.actorLosses);
    }

    getAverageCriticLoss() {
      return this.getAverage(this.criticLosses);
    }

    getAverageReward() {
      return this.getAverage(this.rewards);
    }

    getAverage(list) {
      let sum = 0;
      for (let i = 0; i < list.length; i++) {
        sum += list[i];
      }
      return sum / list.length;
    }
  }

  let config = {
    hiddenUnits: 32,
    obstacles: 0,
    activeHistoryLength: 5,
    cumulativeReward: 0,
    proximityThreshold: 100,
    proximityPenalty: -2,
    collisionPenalty: -5,
    discountFactor: 0.99,
    actorLearningRate: 0.001,
    criticLearningRate: 0.005,
    epsilon: 0.9
  }
  if (localStorage.getItem('config')) {
    let savedConfig = JSON.parse(localStorage.getItem('config'));
    for (const key in savedConfig) {
      config[key] = parseFloat(savedConfig[key]);
    }
  }
  let actorCritic = new ActorCritic(
    3,
    config.activeHistoryLength,
    4,
    window.location.hash.substr(1) === 'reset',
    window.location.hash.substr(1) === 'act',
    config
  );
  document.getElementById("name").innerHTML = actorCritic.name;

</script>
<script>
  class Normalizer {
    normalizeSensorDistance(sensorDistance) {
      sensorDistance = Math.round(sensorDistance / 10);
      return sensorDistance / 20;
    }

    normalizeFeatures(features) {
      let normalized = [];
      features.forEach(function (feature, index) {
          normalized.push(this.normalizeSensorDistance(feature[0]));
          normalized.push(this.normalizeSensorDistance(feature[1]));
          normalized.push(this.normalizeSensorDistance(feature[2]));
      }, this);

      return normalized;
    }
  }

  normalizer = new Normalizer();
</script>
<script>
  class InputListener {
    leftKeyPressed = false;
    rightKeyPressed = false;
    forwardKeyPressed = false;
    backKeyPressed = false;

    listen() {
      var instance = this;
      $('body').on('keydown', function (e) {
        if (e.which === 37) {
          instance.leftKeyPressed = true;
        } else if (e.which === 39) {
          instance.rightKeyPressed = true;
        } else if (e.which === 38) {
          instance.forwardKeyPressed = true;
        } else if (e.which === 40) {
          instance.backKeyPressed = true;
        }
      });
      $('body').on('keyup', function (e) {
        if (e.which === 37) {
          instance.leftKeyPressed = false;
        } else if (e.which === 39) {
          instance.rightKeyPressed = false;
        } else if (e.which === 38) {
          instance.forwardKeyPressed = false;
        } else if (e.which === 40) {
          instance.backKeyPressed = false;
        }
      });
    }
  }

  listener = new InputListener();
  listener.listen();
</script>
<script>
  class Collider {
    constructor(boxes, car, sensor, name, angleOffset) {
      this.boxes = boxes.slice();
      this.car = car;
      this.sensor = sensor;
      this.name = name;
      this.angleOffset = angleOffset;
    }

    getSensorDistance() {
      let sensorDistance = 200;

      let raycastCollisions = raycast(this.boxes, this.sensor.position,
        {
          x: this.sensor.position.x + sensorDistance * Math.cos(this.car.angle + this.angleOffset),
          y: this.sensor.position.y + sensorDistance * Math.sin(this.car.angle + this.angleOffset)
        }
      );
      if (raycastCollisions.length > 0) {
        let firstHit = raycastCollisions[0];
        sensorDistance = Math.sqrt(Math.pow(this.sensor.position.x - firstHit.point.x, 2)
          + Math.pow(this.sensor.position.y - firstHit.point.y, 2));
      }
      // console.log(this.name + ':' + sensorDistance);
      return sensorDistance;
    }
  }
</script>

<script>
  function createHistoryChart(historyData) {
    var canvasContainer = document.getElementById('training-history-container');
    var canvas = document.createElement("CANVAS");
    canvasContainer.style.width = 350;
    canvasContainer.appendChild(canvas);
    historyChart = new Chart(canvas, {
      type: 'line',
      data: {
        labels: Object.keys(historyData["averageActorLoss"]),
        datasets: [
          {
            label: 'Actor loss',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "#E74C3C",
            data: historyData['averageActorLoss']
          },
          {
            label: 'Critic loss',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "#16A085",
            data: historyData['averageCriticLoss']
          },
          {
            label: 'Reward',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "#1634a0",
            data: historyData['averageReward']
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'Evolution average history'
        },
        scales: {
          yAxes: [
            {
              type: "linear",
              display: true,
              position: "left",
              id: "y-axis-1",
            }
          ],
        }
      }
    });
  }

  function resetHistoryChart() {
    historyChart.data.labels = [];
    historyChart.data.datasets[0].data = [];
    historyChart.data.datasets[1].data = [];
    historyChart.data.datasets[2].data = [];

    historyChart.update();
  }

  function pushToHistoryChart(loss, type) {
    if(type === 'actor') {
      historyChart.data.datasets[0].data.push(loss);
      if (historyChart.data.datasets[0].data.length > historyChart.data.labels.length) {
        historyChart.data.labels.push(historyChart.data.datasets[0].data.length);
      }
    } else {
      historyChart.data.datasets[1].data.push(loss);
      if (historyChart.data.datasets[1].data.length > historyChart.data.labels.length) {
        historyChart.data.labels.push(historyChart.data.datasets[1].data.length);
      }
    }
    historyChart.update();
  }

  createHistoryChart(historyData);

</script>

<script>
  function createRewardChart() {
    var canvasContainer = document.getElementById('reward-chart');
    var canvas = document.createElement("CANVAS");
    canvasContainer.style.width = 350;
    canvasContainer.appendChild(canvas);
    rewardChart = new Chart(canvas, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'reward',
            yAxisID: 'y-axis-1',
            fill: false,
            backgroundColor: "#157041",
            borderColor: "blue",
            data: []
          },
          {
            label: 'predicted',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "orange",
            data: [],
          },
          {
            label: 'predicted next',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "green",
            data: [],
          },
          {
            label: 'advantage',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "yellow",
            data: [],
            hidden: true,
          },
          {
            label: 'target',
            yAxisID: 'y-axis-1',
            fill: false,
            borderColor: "gray",
            data: [],
            hidden: true,
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'Reward'
        },
        scales: {
          yAxes: [
            {
              type: "linear",
              display: true,
              position: "left",
              id: "y-axis-1"
            }
          ],
        }
      }
    });
  }

  function pushToRewardChart(step, score, predicted, predictedNext, advantage, target) {
    rewardChart.data.labels.push(step);
    rewardChart.data.datasets[0].data.push(score);
    rewardChart.data.datasets[1].data.push(predicted);
    rewardChart.data.datasets[2].data.push(predictedNext);
    rewardChart.data.datasets[3].data.push(advantage);
    rewardChart.data.datasets[4].data.push(target);
    if (rewardChart.data.labels.length > 50) {
      rewardChart.data.labels.shift();
      rewardChart.data.datasets[0].data.shift();
      rewardChart.data.datasets[1].data.shift();
      rewardChart.data.datasets[2].data.shift();
      rewardChart.data.datasets[3].data.shift();
      rewardChart.data.datasets[4].data.shift();
    }
    rewardChart.update();
  }

  createRewardChart();

</script>
<script>
  function createWeightsChart() {
    var canvasContainer = document.getElementById('weights');
    var canvas = document.createElement("CANVAS");
    canvasContainer.style.width = 350;
    canvasContainer.appendChild(canvas);
    weightsChart = new Chart(canvas, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Right',
            fill: false,
            backgroundColor: "#1238c1",
            data: []
          },
          {
            label: 'Forward',
            fill: false,
            backgroundColor: "#16A085",
            data: []
          },
          {
            label: 'Left',
            fill: false,
            backgroundColor: "#E74C3C",
            data: []
          },
          {
            label: 'Back',
            fill: false,
            backgroundColor: "#e7cb3c",
            data: []
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'Weights'
        },
        scales: {
          xAxes: [{
            stacked: true,
          }],
          yAxes: [{
            stacked: true
          }]
        }
      }
    });
  }

  function pushToWeightsChart(step, weights) {
    weightsChart.data.labels.push(step);
    weightsChart.data.datasets[0].data.push(weights[1]);
    weightsChart.data.datasets[1].data.push(weights[0]);
    weightsChart.data.datasets[2].data.push(weights[2]);
    weightsChart.data.datasets[3].data.push(weights[3]);
    if (weightsChart.data.labels.length > 50) {
      weightsChart.data.labels.shift();
      weightsChart.data.datasets[0].data.shift();
      weightsChart.data.datasets[1].data.shift();
      weightsChart.data.datasets[2].data.shift();
      weightsChart.data.datasets[3].data.shift();
    }
    weightsChart.update();
  }
</script>
<script>
  function createSensorsChart() {
    var canvasContainer = document.getElementById('sensors');
    var canvas = document.createElement("CANVAS");
    canvasContainer.style.width = 350;
    canvasContainer.appendChild(canvas);
    sensorsChart = new Chart(canvas, {
      type: 'bar',
      options: {animation: {duration: 0}},
      data: {
        labels: [],
        datasets: [
          {
            label: 'FR',
            fill: false,
            backgroundColor: "#1238c1",
            data: []
          },
          {
            label: 'FM',
            fill: false,
            backgroundColor: "#16A085",
            data: []
          },
          {
            label: 'FL',
            fill: false,
            backgroundColor: "#E74C3C",
            data: []
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'Sensors'
        },
        scales: {
          xAxes: [{
            stacked: true,
          }],
          yAxes: [{
            stacked: true
          }]
        }
      }
    });
  }

  function pushToSensorsChart(step, state) {
    let latest = state.slice(-1);
    sensorsChart.data.labels.push(step);
    sensorsChart.data.datasets[0].data.push(latest[0][2]);
    sensorsChart.data.datasets[1].data.push(latest[0][1]);
    sensorsChart.data.datasets[2].data.push(latest[0][0]);
    if (sensorsChart.data.labels.length > config.activeHistoryLength) {
      sensorsChart.data.labels.shift();
      sensorsChart.data.datasets[0].data.shift();
      sensorsChart.data.datasets[1].data.shift();
      sensorsChart.data.datasets[2].data.shift();
    }
    sensorsChart.update();
  }

  createSensorsChart();
</script>
<script>
  var sensorsChart,
    historyChart,
    rewardChart,
    weightsChart;
  latest_loss = 1;
  latest_accuracy = 0;

  async function initEnvironment() {
    let Engine = Matter.Engine,
      Render = Matter.Render,
      World = Matter.World,
      Events = Matter.Events,
      Bodies = Matter.Bodies,
      Body = Matter.Body,
      sensorDistanceBM = sensorDistanceFM = sensorDistanceFL = sensorDistanceFR = sensorDistanceMax = 200,
      multiplier = 1;

    createWeightsChart();

    // create an engine
    let engine = Engine.create();
    engine.world.gravity.y = 0;

    // create a renderer
    let environmentWidth = 1000;
    let environmentHeight = 450;
    let render = Render.create({
      element: document.getElementById('environment'),
      engine: engine,
      options: {
        showAngleIndicator: false,
        showDebug: false,
        showVelocity: false,
        showCollisions: false,
        wireframes: false,
        width: environmentWidth,
        height: environmentHeight
      }
    });

    let activeSensorColor = {
        render: {
             fillStyle: 'red',
             strokeStyle: 'blue',
             lineWidth: 3
        }
    }

    //create the car
    let
      carX = 250,
      carY = 200,
      carLength = 50,
      carWidth = carLength / 5 * 3,
      carBody = Bodies.rectangle(carX, carY, carLength, carWidth),
      sensorRadius = carLength / 15,
      carWheelFL = Bodies.rectangle(carX - carLength / 2 + carLength / 3.5, carY - carWidth / 2, carLength / 3.5, carWidth / 3.5),
      carWheelBL = Bodies.rectangle(carX + carLength / 2 - carLength / 3.5, carY - carWidth / 2, carLength / 3.5, carWidth / 3.5),
      carWheelFR = Bodies.rectangle(carX - carLength / 2 + carLength / 3.5, carY + carWidth / 2, carLength / 3.5, carWidth / 3.5),
      carWheelBR = Bodies.rectangle(carX + carLength / 2 - carLength / 3.5, carY + carWidth / 2, carLength / 3.5, carWidth / 3.5),
      sensorBM = Bodies.circle(carX - carLength / 2 + carLength / 15, carY, sensorRadius),
      sensorFM = Bodies.circle(carX + carLength / 2 - carLength / 15, carY, sensorRadius, activeSensorColor),
      sensorFL = Bodies.circle(carX + carLength / 2 - carLength / 15, carY - carWidth / 2 + carLength * 2 / 15, sensorRadius, activeSensorColor),
      sensorFR = Bodies.circle(carX + carLength / 2 - carLength / 15, carY + carWidth / 2 - carLength * 2 / 15, sensorRadius, activeSensorColor),
      car = Body.create({
        parts: [
          carBody,
          carWheelFL,
          carWheelBL,
          carWheelFR,
          carWheelBR,
          sensorBM,
          sensorFM,
          sensorFL,
          sensorFR
        ]
      }),
      collisions = 0;

    let previousState = [],
      state = [],
      previousAction = 0,
      actionBeforePrevious = 0,
      previousReward = 0,
      previousSensorDistanceFM;


    for (let i = 0; i < config.activeHistoryLength; i++) {
      state.push([sensorDistanceMax, sensorDistanceMax, sensorDistanceMax]);
    }

    car.frictionAir = 0.1;

    // create two boxes and a ground
    let boxes = [];

    for (i = 0; i < config.obstacles; i++) {
      let box = Bodies.polygon(300 + environmentWidth/2 * Math.random(), environmentHeight * Math.random(), parseInt(3 + 5 * Math.random()), 10 + 50 * Math.random(), {isStatic: true});
      boxes.push(box);
    }
    let wallB = Bodies.rectangle(environmentWidth/2, environmentHeight, environmentWidth+10, 20, {isStatic: true});
    let wallT = Bodies.rectangle(environmentWidth/2, 0, environmentWidth+10, 20, {isStatic: true});
    let wallL = Bodies.rectangle(0, 205, 20, environmentWidth+10, {isStatic: true});
    let wallR = Bodies.rectangle(environmentWidth, 205, 20, environmentWidth+10, {isStatic: true});
    boxes.push(wallB);
    boxes.push(wallT);
    boxes.push(wallL);
    boxes.push(wallR);

    let colliderBM = new Collider(boxes, car, sensorBM, 'sensorFM', Math.PI);
    let colliderFM = new Collider(boxes, car, sensorFM, 'sensorFM', 0);
    let colliderFL = new Collider(boxes, car, sensorFL, 'sensorFL', -Math.PI / 4);
    let colliderFR = new Collider(boxes, car, sensorFR, 'sensorFR', Math.PI / 4);

    boxes.push(car);

    // add all the bodies to the world
    World.add(engine.world, boxes);

    Events.on(engine, 'collisionStart', function (event) {
      collisions++;
    });
    Events.on(engine, 'collisionActive', function (event) {
      reward += config.collisionPenalty;
    })

    // run the engine
    Engine.run(engine);

    // run the renderer
    Render.run(render);

    async function addInput() {
      let done = false;
      const actions = [
        0, 1, 2, 3
      ];

      sensorDistanceBM = colliderBM.getSensorDistance();
      sensorDistanceFM = colliderFM.getSensorDistance();
      sensorDistanceFL = colliderFL.getSensorDistance();
      sensorDistanceFR = colliderFR.getSensorDistance();

      state.push([
        sensorDistanceFL,
        sensorDistanceFM,
        sensorDistanceFR
      ]);
      state.shift();

      if(!config.cumulativeReward) {
        reward = 0;
      }
      let minVisibleDistance = Math.min(sensorDistanceFM, sensorDistanceFL, sensorDistanceFR);
      if (previousAction === 0 && actionBeforePrevious !== 3 && minVisibleDistance > config.proximityThreshold) {
        reward += sensorDistanceMax;
      }
      if (previousAction === 3) {
        reward -= sensorDistanceMax/10;
      }
      reward -= sensorDistanceMax - sensorDistanceBM;
      reward -= sensorDistanceMax - sensorDistanceFM;
      reward -= sensorDistanceMax - sensorDistanceFL;
      reward -= sensorDistanceMax - sensorDistanceFR;

      let action = actorCritic.getAction(state, actions);
      if (previousState.length > 0) {
        actorCritic.bufferReplay(previousState, previousAction, reward, state);
      }

      previousState = [...state];
      actionBeforePrevious = previousAction;
      previousAction = action;
      previousReward = reward;
      previousSensorDistanceFM = sensorDistanceFM;

      let leftSpeed = 0;
      let rightSpeed = 0;
      switch (action) {
        case 0:
          leftSpeed = 200;
          rightSpeed = 200;
          break;
        case 1:
          leftSpeed = 200;
          rightSpeed = -200;
          break;
        case 2:
          leftSpeed = -200;
          rightSpeed = 200;
          break;
        case 3:
          leftSpeed = -200;
          rightSpeed = -200;
      }

      leftForce = leftSpeed / 40000 * multiplier;
      rightForce = rightSpeed / 40000 * multiplier;

      Body.applyForce(car, {
        x: car.position.x + carLength * Math.sin(car.angle) / 2,
        y: car.position.y - carWidth * Math.cos(car.angle) / 2
      }, {x: leftForce * Math.cos(car.angle), y: leftForce * Math.sin(car.angle)});
      Body.applyForce(car, {
        x: car.position.x - carLength * Math.sin(car.angle) / 2,
        y: car.position.y + carWidth * Math.cos(car.angle) / 2
      }, {x: rightForce * Math.cos(car.angle), y: rightForce * Math.sin(car.angle)});

      if (actorCritic.step > 400 || done || reward < -10000) {
        actorCritic.convertRawTrainingHistory();

        await actorCritic.trainModel();

        actorCritic.save().then( () => {
          historyData['averageActorLoss'].push(
            actorCritic.getAverageActorLoss()
          );
          historyData['averageCriticLoss'].push(
            actorCritic.getAverageCriticLoss()
          );
          historyData['averageReward'].push(
            actorCritic.getAverageReward()
          );
          if (historyData['averageActorLoss'].length > 50) {
            historyData['averageActorLoss'].shift();
            historyData['averageCriticLoss'].shift();
            historyData['averageReward'].shift();
          }
          localStorage.setItem('historyData', JSON.stringify(historyData));

          config.epsilon = Math.min(0.7, (400 - actorCritic.step) * 0.4 / 400 + 0.3);
          saveConfigToStorage();

          window.location.href = window.location.href.split('#')[0];
        });

      } else {
        setTimeout(addInput, 50 / multiplier);
      }
    }

    addInput();
  }

  initEnvironment();
</script>
<script>
  function updateConfigUi() {
    for (const key in config) {
      if (document.getElementById(key)) {
        if(document.getElementById(key).type === 'checkbox') {
          document.getElementById(key).checked = config[key] === 1;
        } else {
          document.getElementById(key).value = config[key];
        }
      }
    }
  }

  document.getElementById('save-reset').onclick = function () {
    saveConfig();
    if (window.location.hash.substr(1) !== 'reset') {
      window.location = window.location + '#reset';
    }
    location.reload();
  };

  function saveConfigToStorage() {
    localStorage.setItem('config', JSON.stringify(config));
  }

  function saveConfig() {
    for (const key in config) {
      if (document.getElementById(key)) {
        if (document.getElementById(key).type === 'checkbox') {
          config[key] = document.getElementById(key).checked === true ? 1 : 0;
        } else {
          config[key] = document.getElementById(key).value;
        }
      }
    }
    saveConfigToStorage();
  }

  document.getElementById('save').onclick = function () {
    saveConfig();
    location.reload();
  }


  document.getElementById('pretrained').onclick = function () {
    let path = 'model/'
    $.get(path + 'config.json', function (data) {
      config = data;
      updateConfigUi();
    });
    actorCritic.load(path + 'actor.json', path + 'critic.json');
  }

  document.getElementById('download').onclick = function () {
    actorCritic.actor.save('downloads://actor');
    actorCritic.critic.save('downloads://critic');
  };
  updateConfigUi();
</script>
</html>